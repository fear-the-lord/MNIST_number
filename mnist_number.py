# -*- coding: utf-8 -*-
"""MNIST_number.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YLlxTXIOhBj7qQ53SY37O37whhVM8Mo_
"""

import tensorflow as tf 
from tensorflow import keras 

import numpy as np 
import matplotlib.pyplot as plt 

from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D

from keras.datasets import mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()
class_names=['Zero','One','Two','Three','Four',
            'Five','Six','Seven','Eight','Nine']

len(x_test)
x_train.shape

len(y_test)
x_test.shape

plt.figure()
plt.imshow(x_train[0])
plt.colorbar()
plt.grid(False)

x_train=x_train/255.0
x_test=x_test/255.0

plt.figure(figsize=(10,10))
for i in range(25):
    plt.subplot(5,5,i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(x_train[i], cmap=plt.cm.binary)
    plt.xlabel(class_names[y_train[i]])

model = keras.Sequential([
     keras.layers.Flatten(input_shape=(28,28)),
     keras.layers.Dense(128, activation=tf.nn.relu),
     keras.layers.Dense(10, activation=tf.nn.softmax),
  
 ])

model.compile(optimizer=keras.optimizers.Adadelta(), 
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy','binary_crossentropy'])

model.fit(x_train, y_train,epochs=15)

test_loss, test_acc = model.evaluate(x_test, y_test)

print('Test accuracy:', test_acc)

predictions=model.predict(x_test)
predictions[0]
np.argmax(predictions[0])
plt.imshow(x_test[0])
y_test[0]

def plot_image(i, predictions_array, true_label, img):
  predictions_array, true_label, img = predictions_array[i], true_label[i], img[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])
  
  plt.imshow(img, cmap=plt.cm.binary)

  predicted_label = np.argmax(predictions_array)
  if predicted_label == true_label:
    color = 'blue'
  else:
    color = 'red'
  
  plt.xlabel("{} {:2.0f}% ({})".format(class_names[predicted_label],
                                100*np.max(predictions_array),
                                class_names[true_label]),
                                color=color)

def plot_value_array(i, predictions_array, true_label):
  predictions_array, true_label = predictions_array[i], true_label[i]
  plt.grid(False)
  plt.xticks([])
  plt.yticks([])
  thisplot = plt.bar(range(10), predictions_array, color="#777777")
  plt.ylim([0, 1]) 
  predicted_label = np.argmax(predictions_array)
 
  thisplot[predicted_label].set_color('red')
  thisplot[true_label].set_color('blue')

i = 0
plt.figure(figsize=(6,3))
plt.subplot(1,2,1)
plot_image(i, predictions, y_test, x_test)
plt.subplot(1,2,2)
plot_value_array(i, predictions,  y_test)

num_rows = 10

num_cols = 5
num_images = num_rows*num_cols
plt.figure(figsize=(2*2*num_cols, 2*num_rows))
for i in range(num_images):
  plt.subplot(num_rows, 2*num_cols, 2*i+1)
  plot_image(i, predictions, y_test, x_test)
  plt.subplot(num_rows, 2*num_cols, 2*i+2)
  plot_value_array(i, predictions, y_test)

